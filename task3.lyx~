#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.5cm
\rightmargin 1.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard

\series bold
CSM13001 Distributed Systems
\end_layout

\begin_layout Standard
Task 3
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Enumerate
In a distributed system with push architecture, the server(s) send(s) informatio
n to the client(s); in pull architecture the client(s) request and receive
 information from the server(s).
 In other words, in push architecture clients receive the data whether they
 need it or not and can choose to do whatever with it -- in pull architecture
 clients only request the data when they need it, or at least 
\emph on
think 
\emph default
they need it.
 
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/pyykkomi/Downloads/pushpull.pdf

\end_inset


\end_layout

\begin_layout Enumerate
Instead of the suggested Python stack, I chose to implement the architecture
 using a 
\emph on
node.js
\emph default
 backend paired with a 
\emph on
React
\emph default
 frontend.
 This was partly because the Python documentation and the ready-made implementat
ions for FCM weren't nowhere as good as the one I chose -- also, it was
 maybe a choice of habit.
\begin_inset Newline newline
\end_inset

The GitHub repository (
\begin_inset CommandInset href
LatexCommand href
name "link"
target "https://github.com/mipyykko/dists-task3"

\end_inset

) contains more documentation on how to run the example locally, but basically
 the backend is a simple web server that sends messages via FCM according
 to the user commands received from the frontend via HTTP endpoints.
 
\begin_inset Newline newline
\end_inset

The frontend prompts the user to get the token from FCM; requests permission
 to show notifications -- even if in this case, the messages are just shown
 in the browser window itself.
 User then registers the client to the backend.
\begin_inset Newline newline
\end_inset

User can give several options on what kind, how much and how often messages
 are sent and issue start/stop commands.
 The list only shows the 10 last received messages to avoid choking the
 browser which may skew the results.
 
\begin_inset Newline newline
\end_inset

Note, that the client can receive messages, even if it didn't initiate the
 message sending itself -- you can test this by opening a second (or several)
 client to another browser window and then starting the sending in one window.
\begin_inset Newline newline
\end_inset


\series bold

\begin_inset Newline newline
\end_inset

Note: 
\series default
The time between sending the messages in testing was a random delay between
 10 and 30 milliseconds.
\series bold

\begin_inset Newline newline
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
1.
\end_layout

\end_inset

Average time sending 50 messages with random payload (of random size): 
\series bold
231.00 
\series default
ms
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
2.
\end_layout

\end_inset

Average time sending 25 messages with fixed message sizes (random payload):
\end_layout

\begin_deeper
\begin_layout Enumerate
Size 5: 
\series bold
190.60 
\series default
ms
\end_layout

\begin_layout Enumerate
Size 25: 
\series bold
165.96 
\series default
ms
\end_layout

\begin_layout Enumerate
Size 50: 
\series bold
211.36 
\series default
ms
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
3.
\end_layout

\end_inset

Inter-arrival rate sending 25 messages of size 25 (random payload): 
\series bold
26.64 
\series default
ms
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
4.
\end_layout

\end_inset

Average times and arrival rates when sending messages of size 25 (random
 payload):
\end_layout

\begin_deeper
\begin_layout Enumerate
100 messages: average 
\series bold
207.36 
\series default
ms, arrival rate 
\series bold
21.36 
\series default
ms
\end_layout

\begin_layout Enumerate
500 messages: average 
\series bold
294.38 
\series default
ms, arrival rate 
\series bold
30.32 
\series default
ms
\end_layout

\begin_layout Enumerate
1000 messages: average 
\series bold
409.52
\series default
 ms, arrival rate 
\series bold
21.78
\series default
 ms
\end_layout

\begin_layout Enumerate
2000 messages: average 
\series bold
319.38 
\series default
ms, arrival rate 
\series bold
21.86 
\series default
ms (11 messages lost)
\end_layout

\begin_layout Enumerate
3000 messages: average 
\series bold
712.22 
\series default
ms, arrival rate 
\series bold
22.24 
\series default
ms (14 messages lost)
\end_layout

\begin_layout Enumerate
5000 messages: average 
\series bold
2579.17 
\series default
ms, arrival rate 
\series bold
23.38 
\series default
ms (20 messages lost)
\end_layout

\begin_layout Standard
After 2000 or so messages the time it takes from sending to receiving starts
 to increase.
 When testing with 5000 messages, the last messages took over 10 seconds
 to arrive.
 This also may explain why messages starts disappearing on their way with
 larger amounts.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
5.
\end_layout

\end_inset

The reliability of push architecture depends on the implementation: if the
 server doesn't know whether the clients actually receive the data they're
 sent, then it can be unreliable.
 If the client is required to send an acknowledgement on each message, then
 the system can be made more reliable, but this does have its drawbacks.
\begin_inset Newline newline
\end_inset

Push architecture is well suited to real-time(ish) applications that can
 have several clients using a single source of data.
 One popular example is a online chat application.
\end_layout

\end_deeper
\end_body
\end_document
